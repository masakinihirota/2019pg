競技プログラミングは
練習した問題を
何回も写経し直す。
理解して、
早く、ミスなく写経できたら卒業。

※設定のバックアップ
VSCode(Visual Studio Code)の設定を同期させる拡張機能「Setting Sync」が便利 | カレリエ
https://www.karelie.net/vscode-setting-sync/

https://t.co/qyiPBg8wne」 / Twitter
https://mobile.twitter.com/chokudai/status/986561875344158720

競技プログラミングレベル別早見表.jpg

白のゾーンに取り組むのがおすすめ。
オレンジは解けなかったら要復習（強い人のコードを見るのは良い）
赤は練習する意味なし。
青ゾーンはチャレンジゾーン。
黒はまだやらない。

AtCoder の
100 点問題は 100 点以上を 10 問練習すればだいたい安定する
200 点問題は 200 点以上を 20 問練習すればだいたい安定する
300 点問題は 300 点以上を 40 問練習すればだいたい安定する
400 点問題は 400 点問題は 80 問くらい練習すればー

[Tutorial] A Way to Practice Competitive Programming : From rating 1000 to 2000 - Codeforces
https://codeforces.com/blog/entry/53341
1000 から 1250 の間で評価を得るためには、
Codeforces の Div.2 コンテストで
少なくとも 1 つの問題を解決する必要があります。
AtCoder では、300 ポイントの問題は評価のレベル 1100-1250 です。

出題形式などの傾向が固まったのが ABC042 から

AtCoder コンテストについての tips - Qiita
https://qiita.com/drken/items/8a6f139158cde8a61dce

レーティング 色 AtCoderJobs ランク レベル感
2800- 赤 SSS 世界レベルのトップ選手です。現在日本に 20 人前後しかいません。
2400-2800 橙 SS 各大学で数年に 1 人レベルのトップ選手です。
2000-2400 黄 S 各大学のエース級選手です。
世間的にはアルゴリズム特化のリサーチャーなど、
エキスパートとして活躍できる実力です。
1600-2000 青 A 世間的にはアルゴリズムスペシャリストとして活躍できる実力です。

1200-1600 水 B 1200 ～ 1600 A, B, C, D の 4 完
世間的にはソフトウェアエンジニアとして
トップレベルの実力です。
Paiza の S ランクと同等とされています。
800-1200 緑 C 600 ～ 1200 A, B, C の 3 完
ソフトウェアエンジニアとして申し分ない実力です。
400-800 茶 D 各大学の情報系学部でしっかりとプログラミングを勉強して上位 3 割の成績を収めている学生さんの実力です
1-400 灰 E 初心者ですが伸びしろがたくさんある状態です

AtCoder は、
プログラミング入門者はまず茶色、
初級者は緑、そこそこ出来る人は水色を目指しましょう、
というのがオススメで、水色まで行けば十分すごいです。

青コーダーって「東証 1 部上場の IT 系会社の１つの中で競プロ最強」
くらいのポジションに普通になれてしまう可能性のある
くらいのレーティングなので、普通に自信持ってください。
黄色クラスがいる会社って日本に２桁しかないと思います。

平均レーティングは 600〜700 (茶色上位相当)（補正をなくした場合）

出来 パフォ 備考
A の 1 完 -600 ～ 0 まずは 2 完を目指しましょう
A, B の 2 完 0 ～ 600 C が解けるようになると楽しくなります
A, B, C の 3 完 600 ～ 1200 スピードに依ります、幅が広いです
A, B, C, D の 4 完 1200 ～ 1600 D が解けるなら ABC は卒業です

100 点 標準入出力・条件分岐・論理演算・四則演算ができる
200 点 ループ・配列・複雑な条件分岐ができる
300 点 オーダの計算・DP・しゃくとり法・貪欲法・STL が少し使える
400 点 上のものが理解できる

2019-05-19(日)
AtCoder Beginner Contest 126
から ABCDEF
100
200
300
400
500
600
の問題が出る。

略語
蟻本
UF = Union Find, p.81
WF = Warshall Floyd, p.98
CHT = Convex Hull Trick, p.304

TLE
Time Limit Exceeded
時間切れ

よく出るアルゴリズム

数学的な計算
GCD(最大公約数)　 ★★★

nCk(mod M)(組み合わせ)　 ★★
特に 10^9+7 の mod 処理が面倒だったのでテンプレート化しました。
ついでに累乗計算も。
累乗計算は底を a/指数を b として O(logb)、nCk(mod M)は O(min(k,n-k)\*logM)の計算量です。

便利なデータ構造
Union-Find 　 ★★★
グルーピングを管理する問題では死ぬほど出てきます。ただ、これそのままの形で解答することはほとんどなく、問題に沿った形に中のデータ構造を変える必要があるケースがほとんどです。例えばグループのノード数を保持するよう変形するとかです。その辺の丁度良い応用力が問いやすいので 400 点でよく出題されるのでしょう。親ノードの抽出とグループの結合をどちらも O(logN)より高速な時間で実行できます。

BinaryIndexedTree 　 ★
部分和の取り出し/配列要素への加算がそれぞれ O(logN)でできるデータ構造です。部分和の取り出しだけだったら普通に累積和でいいんですけど、合間に配列要素への加算操作が必要になってくる場合にはこっちの方が適しています。まああまり見かけないですけど。

その他（PriorityQueue）　 ★★★
後は Java の標準ライブラリでどうにかなると思いますけど、その中でよく使うのは

PriorityQueue
ですかね。要素の追加と最大要素/最小要素の抽出をそれぞれ 0(logN)時間で実行してくれる便利なやつです。ダイクストラでも利用されています。
ただ、デフォルトでは数値型の最小値取得しか受け付けていないので、最大値取得や数値型以外の要素を突っ込む場合には自分で Comparator を定義してあげましょう。
サンプルは int 配列を突っ込んで 0 番目が最大の要素を取得するよう Comparator 定義した PriorityQueue です。

最短経路問題

ダイクストラ　 ★★
計算量はノード数を V、辺数を E として O(ElogV)です。ただし負の辺があるとうまく機能しないので、その場合はベルマンフォードを使います。

ベルマンフォード　 ★★
最短経路問題で負辺があるケースで有効なアルゴリズムです。計算量は O(EV)と、ダイクストラよりやや劣ります。ただ、負の閉路の検出など、ダイクストラではできないことも一部できたりします。負辺があったり、ダイクストラにしてはノード数や辺数の制約がゆるいな？と思ったらこっちのパターンかもしれません。

ワーシャルフロイド　 ★
最短経路問題で全ノード間の最短距離が必要な場合に有効です。計算量はノード数を V として O(V^3)と重めなので、ノード数の制約条件が 100 以下の時ぐらいしか使えないですが、逆に知ってれば解ける場合がほとんどなので覚えておいて損はないです。

最小全域木問題
クラスカル法　 ★★
最小全域木の問題の時によく使います。計算量はノード数を V、辺数を E として O(ElogV)です。ノードの結合状態（同じグループに属しているか）を判定するのに Union-Find を使っています。

テンプレート化できないやつ
累積和
DP（動的計画法）
bit 演算（bit 全探索、xor 問題）
